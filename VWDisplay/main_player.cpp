/*
# Copyright (c) 2014-2016, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <unistd.h>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

#include <VX/vx.h>
#include <NVX/nvx_timer.hpp>

#include "NVX/Application.hpp"
#include "OVX/FrameSourceOVX.hpp"
#include "OVX/RenderOVX.hpp"
#include "NVX/SyncTimer.hpp"
#include "OVX/UtilityOVX.hpp"

unsigned int frameWidth = 1920;
unsigned int frameHeight = 1080;
uint32_t Pixel_Format = VX_DF_IMAGE_RGBX;
unsigned char PBuf[10*1024*1024]; ///< 10MB
uint32_t filesize = 0;

// struct EventData
// {
//     EventData(): alive(true), pause(false) {}

//     bool alive;
//     bool pause;
// };

// static void keyboardEventCallback(void* context, vx_char key, vx_uint32 /*x*/, vx_uint32 /*y*/)
// {
//     EventData* eventData = static_cast<EventData*>(context);
//     if (key == 27) // escape
//     {
//         eventData->alive = false;
//     }
//     else if (key == 32)
//     {
//         eventData->pause = !eventData->pause;
//     }
// }

//
// main - Application entry point
//

int main(int argc, char** argv)
{
    if(argc<3){
        printf("Need two images for displaying\n");
        return 0;
    }
    char* ImgPath0 = argv[1];
    char* ImgPath1 = argv[2];

    nvxio::Application &app = nvxio::Application::get();
    ovxio::printVersionInfo();
    ovxio::ContextGuard context;
    // Messages generated by the OpenVX framework will be processed by ovxio::stdoutLogCallback
    vxRegisterLogCallback(context, &ovxio::stdoutLogCallback, vx_false_e);
    /// 创建一个渲染器
    std::unique_ptr<ovxio::Render> render(ovxio::createDefaultRender(context, "Player Sample", frameWidth, frameHeight));
    if (!render)
    {
        std::cout << "Error: Cannot open default render!" << std::endl;
        return nvxio::Application::APP_EXIT_CODE_NO_RENDER;
    }

    /// 创建一幅图像，指定宽、高、格式
    vx_image frame = vxCreateImage(context, frameWidth, frameHeight, Pixel_Format);

    /// 设定OSD文本框样式
    ovxio::Render::TextBoxStyle style = {{255,255,255,255}, {0,0,0,127}, {10,10}};

    /// 计时
    std::unique_ptr<nvxio::SyncTimer> syncTimer = nvxio::createSyncTimer(); ///< 创建同步计时
    syncTimer->arm(1. / app.getFPSLimit()); ///< 让定时器开始运行
    nvx::Timer totalTimer;
    totalTimer.tic(); ///< 触发定时器
    
    /// 读入图片
    FILE *Img_0 = NULL;
    FILE *Img_1 = NULL;  
    Img_0 = fopen(ImgPath0, "r");
    if(!Img_0){
        printf("Can not open 0000.rgba\n");
    } 
    Img_1 = fopen(ImgPath1, "r");
    if(!Img_1){
        printf("Can not open 0000.rgba\n");
    } 

    /// 创建图像更新补丁
    vx_imagepatch_addressing_t src1_addr;
    src1_addr.dim_x = frameWidth;
    src1_addr.dim_y = frameHeight;
    src1_addr.stride_x = sizeof(vx_uint32);
    src1_addr.stride_y = static_cast<vx_int32>(1920*4);
    vx_rectangle_t rect = {0u, 0u, 1920, 1080};
    vx_rectangle_t rect_patch = {0u, 0u, 960, 540};
    
    int ImgSwitchIdx = 0; ///< 图像切换标志
    uint32_t readSize = 0;

    while(1)
    {
        if(ImgSwitchIdx==0){
            fseek(Img_0, 0L, SEEK_END);  
            filesize = ftell(Img_0); 
            fseek(Img_0, 0L, SEEK_SET);
            readSize = fread(PBuf, 1, filesize, Img_0);
            ImgSwitchIdx=1;
        }else if(ImgSwitchIdx==1){
            fseek(Img_1, 0L, SEEK_END);  
            filesize = ftell(Img_1); 
            fseek(Img_1, 0L, SEEK_SET);
            readSize = fread(PBuf, 1, filesize, Img_1);
            ImgSwitchIdx=0;
        }

        // vx_size patch_size = vxComputeImagePatchSize(frame, &rect_patch, 0); ///< 对于RGB图像，取0



        /// 更新图像数据
        vxCopyImagePatch( frame, &rect, 0, &src1_addr, PBuf, VX_WRITE_ONLY , VX_MEMORY_TYPE_HOST);
        
        syncTimer->synchronize(); ///< 等待一个完整的滴答结束
        double total_ms = totalTimer.toc(); ///< 获取时间

        totalTimer.tic(); ///< 开启下一次滴答

        std::ostringstream txt;
        txt << std::fixed << std::setprecision(1);
        txt << "Source size: " << frameWidth << 'x' << frameHeight << std::endl;
        txt << "Algorithm: " << "No Processing" << std::endl;
        txt << "Display: " << total_ms  << " ms / " << 1000.0 / total_ms << " FPS" << std::endl;
        txt << std::setprecision(6);
        txt.unsetf(std::ios_base::floatfield);
        txt << "LIMITED TO " << app.getFPSLimit() << " FPS FOR DISPLAY" << std::endl;
        txt << "Space - pause/resume" << std::endl;
        // txt << "patch size: " << patch_size << std::endl;
        txt << "Esc - close the demo";
        
        render->putImage(frame); ///< 向渲染器装载图像
        render->putTextViewport(txt.str(), style); ///< 向渲染器装载OSD信息
        if (!render->flush()){ ///< 将数据刷到屏幕上
            printf("Flush failed\n");
        }

        sleep(1);
    }

    fclose(Img_0);
    vxReleaseImage(&frame); ///< 释放图像

    return nvxio::Application::APP_EXIT_CODE_SUCCESS;
}
